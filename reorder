from openpyxl import load_workbook
import pymsteams
import tkinter as tk
from tkinter import messagebox, ttk
from datetime import datetime, timedelta
import os
import copy

# Configuration
EXCEL_FILE = '/Users/ishanasahota/Desktop/fluidAI/rnd_inventory_data_2.xlsx'
REORDER_SHEET = 'ReorderUpdates'
ORDER_TRACKING_SHEET = 'OrderTracking'

# FORMULA TEMPLATES (Enhanced Excel compatibility - no cross-sheet references in complex formulas)
FORMULA_TEMPLATES = {
    'A': "=IF(InventoryData!B{row}=\"\", \"\", InventoryData!B{row})",
    'B': "=IF(InventoryData!F{row}=\"\", \"\", InventoryData!F{row})",
    'C': "=IF(InventoryData!G{row}=\"\", \"\", InventoryData!G{row})",
    'D': "=IF(InventoryData!I{row}=\"\", \"\", InventoryData!I{row})",
    # FIXED: Simplified formulas with better Excel compatibility
    'E': "=IF(D{row}=\"Not Written\",\"Unknown\",IF(D{row}-TODAY()<0,\"Expired\",IF(D{row}-TODAY()<INDEX(ManufacturerLeadTimes!B:B,MATCH(G{row},ManufacturerLeadTimes!A:A,0)),\"Order More\",\"Sufficient time\")))",
    # FIXED: Simplified quantity formula to avoid calculation issues
    'F': "=IF(C{row}=0,\"Empty\",IF(C{row}<(B{row}*0.1),\"Do Not Use\",IF(C{row}<(B{row}*0.2),\"Order More\",\"Sufficient Amount\")))",
    'G': "=IF(InventoryData!H{row}=\"\", \"\", InventoryData!H{row})"
}


def check_prerequisites():
    """Check if all required files and dependencies exist"""
    print("=== CHECKING PREREQUISITES ===")

    # Check if Excel file exists
    if not os.path.exists(EXCEL_FILE):
        error_msg = f"Excel file not found: {EXCEL_FILE}"
        print(f" {error_msg}")
        return False, error_msg

    # Check if file is accessible
    try:
        wb_test = load_workbook(EXCEL_FILE, data_only=True)
        wb_test.close()
        print("Excel file is accessible")
    except Exception as e:
        error_msg = f"Cannot access Excel file: {e}"
        print(f" {error_msg}")
        return False, error_msg

    # Check required sheets
    try:
        wb_test = load_workbook(EXCEL_FILE, data_only=True)
        sheets = wb_test.sheetnames

        required_sheets = ['InventoryData', REORDER_SHEET, 'ManufacturerLeadTimes']
        missing_sheets = [sheet for sheet in required_sheets if sheet not in sheets]

        if missing_sheets:
            error_msg = f"Missing required sheets: {missing_sheets}"
            print(f" {error_msg}")
            wb_test.close()
            return False, error_msg

        print("All required sheets found")
        wb_test.close()

    except Exception as e:
        error_msg = f"Error checking sheets: {e}"
        print(f" {error_msg}")
        return False, error_msg

    print(" All prerequisites met")
    return True, "Prerequisites OK"


def force_formula_recalculation():
    """Force Excel to properly recalculate formulas and resolve #NAME errors"""
    try:
        print("=== FORCING FORMULA RECALCULATION ===")
        wb = load_workbook(EXCEL_FILE, data_only=False)
        ws = wb[REORDER_SHEET]

        # Method 1: Touch each formula cell to force recalculation
        problem_cells_fixed = 0
        for row_num in range(2, ws.max_row + 1):
            for col_letter in ['E', 'F']:
                cell_ref = f"{col_letter}{row_num}"
                cell = ws[cell_ref]

                if cell.value and str(cell.value).startswith('='):
                    # Store original formula
                    original_formula = str(cell.value)

                    # ENHANCED: Clean up common Excel compatibility issues
                    clean_formula = original_formula

                    # Fix VLOOKUP issues - use INDEX/MATCH instead for better compatibility
                    if 'VLOOKUP' in clean_formula and col_letter == 'E':
                        # Replace VLOOKUP with INDEX/MATCH for better compatibility
                        clean_formula = f"=IF(D{row_num}=\"Not Written\",\"Unknown\",IF(D{row_num}-TODAY()<0,\"Expired\",IF(D{row_num}-TODAY()<INDEX(ManufacturerLeadTimes!B:B,MATCH(G{row_num},ManufacturerLeadTimes!A:A,0)),\"Order More\",\"Sufficient time\")))"

                    # Fix quantity formula issues
                    elif col_letter == 'F':
                        # Ensure proper parentheses and no text/number conflicts
                        clean_formula = f"=IF(C{row_num}=0,\"Empty\",IF(C{row_num}<(B{row_num}*0.1),\"Do Not Use\",IF(C{row_num}<(B{row_num}*0.2),\"Order More\",\"Sufficient Amount\")))"

                    # Clear cell completely
                    cell.value = None

                    # Re-enter the cleaned formula
                    cell.value = clean_formula
                    problem_cells_fixed += 1

        # Method 2: Set calculation properties to force recalculation
        try:
            if hasattr(wb, 'calculation'):
                if hasattr(wb.calculation, 'calcMode'):
                    wb.calculation.calcMode = 'automatic'
                if hasattr(wb.calculation, 'fullCalcOnLoad'):
                    wb.calculation.fullCalcOnLoad = True
        except Exception as calc_error:
            print(f"Note: Could not set calculation properties: {calc_error}")

        # Method 3: Force recalculation by adding and removing a volatile function
        temp_cell = ws['AA1']
        temp_cell.value = '=NOW()'

        # Method 4: Set all formula cells to be calculated
        for row_num in range(2, ws.max_row + 1):
            for col_letter in ['E', 'F']:
                cell_ref = f"{col_letter}{row_num}"
                cell = ws[cell_ref]
                if cell.value and str(cell.value).startswith('='):
                    # Force the cell to recalculate by touching it
                    cell.value = cell.value

        print(f"Processed {problem_cells_fixed} formula cells for recalculation")

        # Save the workbook
        wb.save(EXCEL_FILE)

        # Remove the temporary cell
        temp_cell.value = None
        wb.save(EXCEL_FILE)
        wb.close()

        # ADDITIONAL: Try to force Excel to recalculate by reopening
        print("Performing additional recalculation pass...")
        wb2 = load_workbook(EXCEL_FILE, data_only=False)
        wb2.save(EXCEL_FILE)
        wb2.close()

        print("Formula recalculation completed")
        return True

    except Exception as e:
        print(f"Error forcing formula recalculation: {e}")
        return False


def backup_reorder_formulas():
    """Backup all formulas from ReorderUpdates sheet"""
    try:
        print("=== BACKING UP REORDER FORMULAS ===")
        wb_backup = load_workbook(EXCEL_FILE, data_only=False)
        ws_reorder = wb_backup[REORDER_SHEET]

        formula_backup = {}
        max_row = ws_reorder.max_row
        max_col = ws_reorder.max_column

        # Backup all formulas
        for row_num in range(1, max_row + 1):
            for col_num in range(1, max_col + 1):
                cell = ws_reorder.cell(row=row_num, column=col_num)
                if cell.value and str(cell.value).startswith('='):
                    cell_ref = f"{chr(64 + col_num)}{row_num}"  # Convert to A1 notation
                    formula_backup[cell_ref] = str(cell.value)

        wb_backup.close()

        print(f"Backed up {len(formula_backup)} formulas from ReorderUpdates sheet")
        return formula_backup, max_row

    except Exception as e:
        print(f"Error backing up formulas: {e}")
        return {}, 0


def restore_reorder_formulas(formula_backup, expected_max_row):
    """Restore formulas to ReorderUpdates sheet with proper Excel compatibility"""
    try:
        print("=== RESTORING REORDER FORMULAS ===")
        wb_restore = load_workbook(EXCEL_FILE, data_only=False)
        ws_reorder = wb_restore[REORDER_SHEET]

        restored_count = 0

        # First, try to restore from backup
        for cell_ref, formula in formula_backup.items():
            try:
                # Clean up any _xlfn or _xludf prefixes from backed up formulas
                clean_formula = formula.replace("_xlfn.", "").replace("_xludf.", "")
                ws_reorder[cell_ref] = clean_formula
                restored_count += 1
            except Exception as e:
                print(f"Error restoring formula for {cell_ref}: {e}")

        # Second, check if we need to regenerate any missing formulas
        current_max_row = max(ws_reorder.max_row, expected_max_row)
        regenerated_count = 0

        # STAGED APPROACH: Restore formulas in dependency order
        # Stage 1: Simple reference formulas first (A, B, C, D, G)
        simple_columns = ['A', 'B', 'C', 'D', 'G']
        complex_columns = ['E', 'F']

        print("Stage 1: Restoring simple reference formulas...")
        for row_num in range(2, current_max_row + 1):
            for col_letter in simple_columns:
                col_num = ord(col_letter) - 64
                cell = ws_reorder.cell(row=row_num, column=col_num)
                cell_ref = f"{col_letter}{row_num}"

                if not (cell.value and str(cell.value).startswith('=')):
                    if col_letter in FORMULA_TEMPLATES:
                        formula = FORMULA_TEMPLATES[col_letter].format(row=row_num)
                        cell.value = formula
                        regenerated_count += 1

        # Save intermediate state
        print("Saving intermediate state...")
        wb_restore.save(EXCEL_FILE)

        print("Stage 2: Restoring complex interdependent formulas...")
        # Stage 2: Complex formulas that depend on other cells in the same sheet
        for row_num in range(2, current_max_row + 1):
            for col_letter in complex_columns:
                col_num = ord(col_letter) - 64
                cell = ws_reorder.cell(row=row_num, column=col_num)

                if not (cell.value and str(cell.value).startswith('=')):
                    if col_letter in FORMULA_TEMPLATES:
                        formula = FORMULA_TEMPLATES[col_letter].format(row=row_num)
                        # ENHANCED: Additional formula cleaning for Excel compatibility
                        if col_letter == 'E':
                            # Ensure proper spacing and syntax for Excel
                            formula = f"=IF(D{row_num}=\"Not Written\",\"Unknown\",IF(D{row_num}-TODAY()<0,\"Expired\",IF(D{row_num}-TODAY()<INDEX(ManufacturerLeadTimes!B:B,MATCH(G{row_num},ManufacturerLeadTimes!A:A,0)),\"Order More\",\"Sufficient time\")))"
                        elif col_letter == 'F':
                            # Ensure proper parentheses and decimal handling
                            formula = f"=IF(C{row_num}=0,\"Empty\",IF(C{row_num}<(B{row_num}*0.1),\"Do Not Use\",IF(C{row_num}<(B{row_num}*0.2),\"Order More\",\"Sufficient Amount\")))"

                        cell.value = formula
                        regenerated_count += 1

        wb_restore.save(EXCEL_FILE)
        wb_restore.close()

        print(f"Restored {restored_count} formulas from backup")
        print(f"Regenerated {regenerated_count} missing formulas")
        print(" FORMULA RESTORATION COMPLETE")

        return True

    except Exception as e:
        print(f"Error restoring formulas: {e}")
        return False


def main_reorder_alert():
    """Enhanced reorder alert with comprehensive error handling"""
    formula_backup = {}
    original_max_row = 0

    try:
        # Step 0: Check prerequisites first
        prereq_ok, prereq_msg = check_prerequisites()
        if not prereq_ok:
            print(f" Prerequisites failed: {prereq_msg}")
            try:
                messagebox.showerror("Prerequisites Error", prereq_msg)
            except:
                pass
            return False

        # Step 1: Backup formulas before any operations
        formula_backup, original_max_row = backup_reorder_formulas()

        # Step 2: Load workbook for READING calculated values ONLY
        print("Loading workbook for reading calculated values...")
        wb_read = load_workbook(EXCEL_FILE, data_only=True)
        ws = wb_read[REORDER_SHEET]

        # Get headers from the sheet
        headers = []
        for cell in ws[1]:
            headers.append(str(cell.value or ""))

        # Find the indices for the alert columns
        expiry_alert_col = None
        quantity_alert_col = None

        for i, header in enumerate(headers):
            if 'expiry' in header.lower() and 'alert' in header.lower():
                expiry_alert_col = i
            elif 'quantity' in header.lower() or 'empty' in header.lower():
                quantity_alert_col = i

        if expiry_alert_col is None:
            expiry_alert_col = 4  # Column E
        if quantity_alert_col is None:
            quantity_alert_col = 5  # Column F

        table_rows = []
        actionable_items = []
        status_counts = {}  # Track what statuses we're seeing

        # Process data rows
        for row in ws.iter_rows(min_row=2, values_only=True):
            if not row or len(row) < max(expiry_alert_col, quantity_alert_col) + 1:
                continue

            expiry_alert = str(row[expiry_alert_col] or "").strip()
            quantity_alert = str(row[quantity_alert_col] or "").strip()

            # Track status combinations
            status_key = f"Expiry: {expiry_alert} | Quantity: {quantity_alert}"
            status_counts[status_key] = status_counts.get(status_key, 0) + 1

            # Skip items that are sufficient
            if (expiry_alert.lower() == "sufficient time" and
                    quantity_alert.lower() == "sufficient amount"):
                continue

            # This row needs attention
            table_row = []
            for i, cell_value in enumerate(row):
                if i < len(headers):
                    cell_str = str(cell_value or "")
                    if len(cell_str) > 20:
                        cell_str = cell_str[:17] + "..."
                    table_row.append(cell_str)

            table_rows.append(table_row)

            # Check if needs immediate action - EXPANDED CRITERIA
            item_name = str(row[0] or "").strip()

            # Original strict criteria
            if (expiry_alert in ["Expired", "Order More"] or
                    quantity_alert in ["Empty", "Order More"]):
                actionable_items.append({
                    'name': item_name,
                    'expiry_status': expiry_alert,
                    'quantity_status': quantity_alert,
                    'row_data': row
                })

        # Debug: Print status breakdown
        print("\n=== STATUS BREAKDOWN ===")
        for status, count in sorted(status_counts.items()):
            print(f"{count:4d} items: {status}")
        print("=" * 50)

        # Close the read workbook immediately
        print("Closing read workbook...")
        wb_read.close()
        del wb_read

        # Step 3: Create and send Teams message
        def create_reorder_table(headers, rows):
            if not rows:
                return "**All chemicals have sufficient time remaining!** "

            header_row = "| " + " | ".join(headers) + " |\n"
            separator = "|" + "|".join(["-" * max(8, len(h)) for h in headers]) + "|\n"

            data_rows = ""
            for row in rows:
                padded_row = row + [""] * (len(headers) - len(row))
                data_rows += "| " + " | ".join(padded_row[:len(headers)]) + " |\n"

            return header_row + separator + data_rows

        table_content = create_reorder_table(headers, table_rows)

        # Calculate summary stats
        expired_count = sum(
            1 for item in actionable_items if "Expired" in [item['expiry_status'], item['quantity_status']])
        empty_count = sum(1 for item in actionable_items if "Empty" in [item['expiry_status'], item['quantity_status']])
        order_count = sum(
            1 for item in actionable_items if "Order More" in [item['expiry_status'], item['quantity_status']])

        priority_summary = f"🔴 **Critical Items:** {expired_count} expired, {empty_count} empty, {order_count} need ordering"

        # Send to Teams (with error handling)
        try:
            webhook_url = "https://nervtechnology2.webhook.office.com/webhookb2/9b48b976-ff78-47d9-84af-0c86adb460bd@c943a20e-cde2-4f23-b31e-66242a699eb2/IncomingWebhook/2efe91b202c844cd9e3ad8f664443bb3/756d53aa-a382-47d3-9d8c-2d22fa02b8a3/V24Osd4C7KfMwor8lyRXSbBRdZcuzt6wgDMRlLNuh9QtE1"

            msg_reorder = pymsteams.connectorcard(webhook_url)
            msg_reorder.text(
                "**📋 Complete Chemical Inventory Status Report**\n\n"
                f"{priority_summary}\n\n"
                f"**Total items requiring attention: {len(table_rows)}**\n\n"
                "Below is a complete view of all chemicals that don't have sufficient time remaining:\n\n"
                f"{table_content}"
            )
            msg_reorder.send()
            print(" Teams message sent successfully")
        except Exception as teams_error:
            print(f" Teams message failed (non-critical): {teams_error}")

        # Step 4: Show GUI for marking items as ordered (if any actionable items)
        if actionable_items:
            print(f"Found {len(actionable_items)} actionable items - showing GUI...")
            try:
                show_order_marking_gui(actionable_items, formula_backup, original_max_row)
            except Exception as gui_error:
                print(f" GUI failed (non-critical): {gui_error}")
                import traceback
                traceback.print_exc()
        else:
            print("No actionable items found with STRICT criteria - GUI will not be shown")
            print("Items needing GUI are those with status: 'Expired', 'Order More', or 'Empty'")

            # OPTION: Show GUI for ALL items requiring attention instead?
            if table_rows and len(table_rows) > 0:
                print(f"\nHowever, there are {len(table_rows)} items requiring attention.")
                print("Would you like to modify the code to show GUI for ALL items requiring attention?")
                print("This would include items with status: 'Do Not Use', 'Unknown', etc.")

                # For now, let's create actionable items from ALL items requiring attention
                print("\n🔧 SHOWING GUI FOR ALL ITEMS REQUIRING ATTENTION...")

                # Convert table_rows back to actionable format
                expanded_actionable = []
                row_index = 0
                for row in ws.iter_rows(min_row=2, values_only=True):
                    if not row or len(row) < max(expiry_alert_col, quantity_alert_col) + 1:
                        continue

                    expiry_alert = str(row[expiry_alert_col] or "").strip()
                    quantity_alert = str(row[quantity_alert_col] or "").strip()

                    # Skip ONLY items that are completely sufficient
                    if (expiry_alert.lower() == "sufficient time" and
                            quantity_alert.lower() == "sufficient amount"):
                        continue

                    # Include ALL other items
                    item_name = str(row[0] or "").strip()
                    expanded_actionable.append({
                        'name': item_name,
                        'expiry_status': expiry_alert,
                        'quantity_status': quantity_alert,
                        'row_data': row
                    })

                if expanded_actionable:
                    print(f"Showing GUI for {len(expanded_actionable)} items requiring attention...")
                    try:
                        show_order_marking_gui(expanded_actionable, formula_backup, original_max_row)
                    except Exception as gui_error:
                        print(f" GUI failed (non-critical): {gui_error}")
                        import traceback
                        traceback.print_exc()

        print(
            f" Reorder alert completed successfully. Found {len(table_rows)} items requiring attention, {len(actionable_items)} needing immediate action.")
        return True

    except Exception as e:
        print(f" Error in main reorder alert: {e}")
        try:
            messagebox.showerror("Error", f"Error in reorder alert: {e}")
        except:
            pass
        return False

    finally:
        # Always try to restore formulas if we have a backup
        if formula_backup:
            print("=== FINAL FORMULA RESTORATION ===")
            restore_success = restore_reorder_formulas(formula_backup, original_max_row)

            if restore_success:
                # NEW: Additional force recalculation step
                print("=== ADDITIONAL RECALCULATION STEP ===")
                force_formula_recalculation()
            else:
                print(" FORMULA RESTORATION FAILED - MANUAL INTERVENTION MAY BE NEEDED")


def show_order_marking_gui(actionable_items, formula_backup, original_max_row):
    """Show GUI for marking items as ordered"""
    try:
        print(f"=== INITIALIZING GUI ===")
        print(f"Number of actionable items: {len(actionable_items)}")

        # Force GUI to appear on top and be visible
        root = tk.Tk()
        root.title("Mark Items as Ordered")
        root.geometry("800x600")
        root.lift()  # Bring window to front
        root.attributes('-topmost', True)  # Keep on top temporarily
        root.after(100, lambda: root.attributes('-topmost', False))  # Remove topmost after 100ms
        root.focus_force()  # Force focus

        print("Tkinter window created successfully")

        main_frame = ttk.Frame(root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        title_label = ttk.Label(main_frame, text="Items Requiring Immediate Attention",
                                font=('Arial', 12, 'bold'))
        title_label.grid(row=0, column=0, columnspan=3, pady=(0, 10))

        instructions = ttk.Label(main_frame,
                                 text="Select items that have been ordered or are being processed:")
        instructions.grid(row=1, column=0, columnspan=3, pady=(0, 10))

        columns = ('Chemical', 'Expiry Status', 'Quantity Status', 'Action Needed')
        tree = ttk.Treeview(main_frame, columns=columns, show='headings', height=15)

        tree.heading('Chemical', text='Chemical Name')
        tree.heading('Expiry Status', text='Expiry Status')
        tree.heading('Quantity Status', text='Quantity Status')
        tree.heading('Action Needed', text='Priority')

        tree.column('Chemical', width=250)
        tree.column('Expiry Status', width=120)
        tree.column('Quantity Status', width=120)
        tree.column('Action Needed', width=100)

        print("Adding items to tree...")
        for i, item in enumerate(actionable_items):
            priority = "🔴 URGENT" if (item['expiry_status'] in ["Expired", "Empty"] or
                                      item['quantity_status'] in ["Expired", "Empty"]) else "🟡 Order Soon"

            tree.insert('', 'end', iid=i, values=(
                item['name'],
                item['expiry_status'],
                item['quantity_status'],
                priority
            ))
            print(f"Added item {i + 1}: {item['name']}")

        tree.grid(row=2, column=0, columnspan=3, pady=(0, 10), sticky=(tk.W, tk.E))

        scrollbar = ttk.Scrollbar(main_frame, orient='vertical', command=tree.yview)
        scrollbar.grid(row=2, column=3, sticky=(tk.N, tk.S))
        tree.configure(yscrollcommand=scrollbar.set)

        selection_info = ttk.Label(main_frame, text="Tip: Use Ctrl+Click to select multiple items")
        selection_info.grid(row=3, column=0, columnspan=3, pady=(5, 10))

        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=4, column=0, columnspan=3, pady=10)

        def mark_selected_as_ordered():
            print("Mark selected button clicked")
            selected_items = tree.selection()
            if not selected_items:
                messagebox.showwarning("No Selection", "Please select at least one item to mark as ordered.")
                return

            print(f"Selected {len(selected_items)} items")
            order_dialog = OrderDetailsDialog(root)
            order_details = order_dialog.get_order_details()

            if order_details:
                print(f"Order details received: {order_details}")
                marked_count = 0
                for item_id in selected_items:
                    item_index = int(item_id)
                    item = actionable_items[item_index]

                    if mark_item_as_ordered_in_sheet(
                            item['name'],
                            order_details['supplier'],
                            order_details['order_date'],
                            order_details['pr_number'],
                            formula_backup,
                            original_max_row
                    ):
                        marked_count += 1
                        tree.delete(item_id)

                messagebox.showinfo("Success",
                                    f"Successfully marked {marked_count} items as ordered!\n\n"
                                    f"These items are now tracked in the system.")

                if not tree.get_children():
                    messagebox.showinfo("Complete", "All items have been processed!")
                    root.destroy()
            else:
                print("Order details dialog was cancelled")

        def select_all():
            print("Select all button clicked")
            for child in tree.get_children():
                tree.selection_add(child)

        ttk.Button(button_frame, text="Select All", command=select_all).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Mark Selected as Ordered",
                   command=mark_selected_as_ordered).pack(side='left', padx=5)

        root.columnconfigure(0, weight=1)
        root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(2, weight=1)

        root.update_idletasks()
        x = (root.winfo_screenwidth() // 2) - (root.winfo_width() // 2)
        y = (root.winfo_screenheight() // 2) - (root.winfo_height() // 2)
        root.geometry(f"+{x}+{y}")

        print("Starting GUI main loop...")
        root.mainloop()
        print("GUI main loop ended")

    except Exception as e:
        print(f"Error showing order marking GUI: {e}")
        import traceback
        traceback.print_exc()


class OrderDetailsDialog:
    def __init__(self, parent):
        self.result = None
        self.dialog = tk.Toplevel(parent)
        self.dialog.title("Order Details")
        self.dialog.geometry("400x300")
        self.dialog.transient(parent)
        self.dialog.grab_set()

        self.dialog.update_idletasks()
        x = (parent.winfo_x() + parent.winfo_width() // 2) - (self.dialog.winfo_width() // 2)
        y = (parent.winfo_y() + parent.winfo_height() // 2) - (self.dialog.winfo_height() // 2)
        self.dialog.geometry(f"+{x}+{y}")

        self.create_widgets()

    def create_widgets(self):
        main_frame = ttk.Frame(self.dialog, padding="20")
        main_frame.pack(fill='both', expand=True)

        ttk.Label(main_frame, text="Enter Order Details",
                  font=('Arial', 12, 'bold')).grid(row=0, column=0, columnspan=2, pady=(0, 20))

        ttk.Label(main_frame, text="Supplier/Vendor:").grid(row=1, column=0, sticky='w', pady=5)
        self.supplier_entry = ttk.Entry(main_frame, width=30)
        self.supplier_entry.grid(row=1, column=1, pady=5, padx=(10, 0))

        ttk.Label(main_frame, text="Order Date:").grid(row=2, column=0, sticky='w', pady=5)
        self.date_entry = ttk.Entry(main_frame, width=30)
        self.date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.date_entry.grid(row=2, column=1, pady=5, padx=(10, 0))

        ttk.Label(main_frame, text="PR Number:").grid(row=3, column=0, sticky='w', pady=5)
        self.pr_number_entry = ttk.Entry(main_frame, width=30)
        self.pr_number_entry.grid(row=3, column=1, pady=5, padx=(10, 0))

        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=4, column=0, columnspan=2, pady=20)

        ttk.Button(button_frame, text="OK", command=self.ok_clicked).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Cancel", command=self.cancel_clicked).pack(side='left', padx=5)

        self.supplier_entry.focus()

    def ok_clicked(self):
        supplier = self.supplier_entry.get().strip()
        if not supplier:
            messagebox.showwarning("Missing Information", "Please enter a supplier name.")
            return

        self.result = {
            'supplier': supplier,
            'order_date': self.date_entry.get().strip(),
            'pr_number': self.pr_number_entry.get().strip()
        }
        self.dialog.destroy()

    def cancel_clicked(self):
        self.result = None
        self.dialog.destroy()

    def get_order_details(self):
        self.dialog.wait_window()
        return self.result


def mark_item_as_ordered_in_sheet(chemical_name, supplier, order_date, pr_number, formula_backup, original_max_row):
    """Mark item as ordered - with comprehensive formula preservation"""
    try:
        print(f"\n=== MARKING ITEM AS ORDERED: {chemical_name} ===")

        # Load for writing - ONLY touch InventoryData and OrderTracking sheets
        print("Loading workbook for WRITE operations...")
        wb_write = load_workbook(EXCEL_FILE, data_only=False)

        # Get or create order tracking sheet
        if ORDER_TRACKING_SHEET in wb_write.sheetnames:
            ws_tracking = wb_write[ORDER_TRACKING_SHEET]
        else:
            ws_tracking = wb_write.create_sheet(ORDER_TRACKING_SHEET)
            # Updated headers to include PR Number in column 4
            headers = ['Chemical Name', 'Manufacturer', 'Order Date', 'PR Number', 'Order Status', 'Expected Delivery',
                       'Auto Delete Date']
            for i, header in enumerate(headers, 1):
                ws_tracking.cell(row=1, column=i, value=header)

        next_row = ws_tracking.max_row + 1

        expected_delivery = calculate_expected_delivery(wb_write, supplier, order_date)
        auto_delete_date = calculate_auto_delete_date(expected_delivery)

        # Add order record with PR Number in column 4
        ws_tracking.cell(row=next_row, column=1, value=chemical_name)
        ws_tracking.cell(row=next_row, column=2, value=supplier)
        ws_tracking.cell(row=next_row, column=3, value=order_date)
        ws_tracking.cell(row=next_row, column=4, value=pr_number)  # PR Number column
        ws_tracking.cell(row=next_row, column=5, value="Ordered")  # Order Status moved to column 5
        ws_tracking.cell(row=next_row, column=6, value=expected_delivery)
        ws_tracking.cell(row=next_row, column=7, value=auto_delete_date)

        # Remove from InventoryData ONLY
        print("Removing from InventoryData...")
        removed_inventory = remove_from_inventory_data(wb_write, chemical_name, supplier)

        # Save and close
        print("Saving workbook...")
        wb_write.save(EXCEL_FILE)
        wb_write.close()

        # IMMEDIATELY restore formulas after any write operation
        print("Restoring formulas immediately after write operation...")
        restore_reorder_formulas(formula_backup, original_max_row)

        print(
            f"Successfully marked '{chemical_name}' as ordered with PR Number: {pr_number}. Removed {removed_inventory} inventory rows.")
        return True

    except Exception as e:
        print(f"Error marking item as ordered: {e}")
        # Even on error, try to restore formulas
        if formula_backup:
            print("Attempting formula restoration after error...")
            restore_reorder_formulas(formula_backup, original_max_row)
        return False


def remove_from_inventory_data(workbook, chemical_name, manufacturer):
    """Remove matching rows from InventoryData sheet ONLY"""
    try:
        ws_inventory = workbook['InventoryData']
        rows_to_delete = []

        for row_num in range(ws_inventory.max_row, 1, -1):
            row = ws_inventory[row_num]

            item_name = str(row[1].value or "").strip()  # Column B
            item_manufacturer = str(row[7].value or "").strip()  # Column H

            if (item_name.lower() == chemical_name.lower() and
                    item_manufacturer.lower() == manufacturer.lower()):
                rows_to_delete.append(row_num)

        for row_num in rows_to_delete:
            ws_inventory.delete_rows(row_num)

        return len(rows_to_delete)

    except Exception as e:
        print(f"Error removing from InventoryData: {e}")
        return 0


def calculate_expected_delivery(workbook, manufacturer, order_date):
    """Calculate expected delivery date"""
    try:
        if isinstance(order_date, str):
            try:
                order_dt = datetime.strptime(order_date, "%Y-%m-%d")
            except ValueError:
                try:
                    order_dt = datetime.strptime(order_date, "%m/%d/%Y")
                except ValueError:
                    try:
                        order_dt = datetime.strptime(order_date, "%d/%m/%Y")
                    except ValueError:
                        order_dt = datetime.now()
        else:
            order_dt = datetime.now()

        lead_time_days = get_manufacturer_leadtime(manufacturer, workbook)
        expected_delivery_dt = order_dt + timedelta(days=lead_time_days)

        return expected_delivery_dt.strftime("%Y-%m-%d")

    except Exception as e:
        print(f"Error calculating expected delivery: {e}")
        return (datetime.now() + timedelta(days=14)).strftime("%Y-%m-%d")


def calculate_auto_delete_date(expected_delivery):
    """Calculate auto delete date"""
    try:
        if isinstance(expected_delivery, str):
            expected_dt = datetime.strptime(expected_delivery, "%Y-%m-%d")
        else:
            expected_dt = datetime.now()

        auto_delete_dt = expected_dt + timedelta(days=30)
        return auto_delete_dt.strftime("%Y-%m-%d")

    except Exception as e:
        print(f"Error calculating auto delete date: {e}")
        return (datetime.now() + timedelta(days=44)).strftime("%Y-%m-%d")


def get_manufacturer_leadtime(manufacturer, workbook):
    """Get lead time for manufacturer"""
    try:
        ws_leadtimes = workbook['ManufacturerLeadTimes']

        for row in ws_leadtimes.iter_rows(min_row=2, values_only=True):
            if not row or len(row) < 2:
                continue

            mfg_name = str(row[0] or "").strip()
            lead_time = row[1]

            if mfg_name.lower() == manufacturer.lower():
                try:
                    return int(lead_time)
                except (TypeError, ValueError):
                    return 14

        return 14

    except Exception as e:
        print(f"Error getting lead time for manufacturer '{manufacturer}': {e}")
        return 14


# Add this simple test function to verify the script works
def test_basic_functionality():
    """Test basic functionality without full execution"""
    print("=== TESTING BASIC FUNCTIONALITY ===")

    try:
        prereq_ok, prereq_msg = check_prerequisites()
        print(f"Prerequisites: {prereq_msg}")

        if not prereq_ok:
            print(" Cannot proceed - prerequisites failed")
            return False

        print(" Basic functionality test passed")
        return True

    except Exception as e:
        print(f" Basic functionality test failed: {e}")
        return False


def debug_formula_issues():
    """Debug function to check what's happening with formulas"""
    try:
        print("=== DEBUGGING FORMULA ISSUES ===")
        wb = load_workbook(EXCEL_FILE, data_only=False)
        ws = wb[REORDER_SHEET]

        # Check first few rows to see formula status
        for row_num in range(2, min(7, ws.max_row + 1)):  # Check first 5 data rows
            print(f"\nRow {row_num}:")
            for col_letter in ['E', 'F']:
                cell_ref = f"{col_letter}{row_num}"
                cell = ws[cell_ref]
                cell_value = cell.value

                if cell_value and str(cell_value).startswith('='):
                    print(f"  {col_letter}{row_num}: FORMULA = {cell_value}")
                elif cell_value:
                    print(f"  {col_letter}{row_num}: VALUE = {cell_value}")
                else:
                    print(f"  {col_letter}{row_num}: EMPTY")

        # Now check with calculated values
        wb.close()

        print("\n=== CALCULATED VALUES ===")
        wb_calc = load_workbook(EXCEL_FILE, data_only=True)
        ws_calc = wb_calc[REORDER_SHEET]

        for row_num in range(2, min(7, ws_calc.max_row + 1)):
            print(f"\nRow {row_num} calculated:")
            for col_letter in ['E', 'F']:
                cell_ref = f"{col_letter}{row_num}"
                cell = ws_calc[cell_ref]
                print(f"  {col_letter}{row_num}: {cell.value}")

        wb_calc.close()

    except Exception as e:
        print(f"Error in debug function: {e}")


if __name__ == "__main__":
    print(" Starting Chemical Inventory Alert System...")

    # First run a basic test
    if test_basic_functionality():
        print("\n" + "=" * 50)
        print("RUNNING MAIN ALERT SYSTEM")
        print("=" * 50)
        success = main_reorder_alert()

        if success:
            print("\n Chemical Inventory Alert System completed successfully!")

            # Add debug check for formula issues
            print("\n🔧 Running formula debug check...")
            debug_formula_issues()

        else:
            print("\n Chemical Inventory Alert System encountered errors!")

    else:
        print("\n Cannot run main system - basic tests failed!")
        print("Please check the error messages above and fix the issues.")
