from openpyxl import load_workbook
import pymsteams
from collections import defaultdict
import tkinter as tk
from tkinter import messagebox


try:
    # Load workbook and InventoryData
    wb = load_workbook('/Users/ishanasahota/Desktop/fluidAI/rnd_inventory_data_2.xlsx', data_only=True)
    ws = wb['InventoryData']

    # PART 1: Weekly Summary of Critical Fluids with Table Format
    keywords = [
        "buffer solution ph 4", "buffer solution ph 5", "buffer solution ph 7",
        "buffer solution ph 8", "buffer solution ph 9", "buffer solution ph 10",
        "ph 4 buffer solution", "ph 5 buffer solution", "ph 7 buffer solution",
        "ph 8 buffer solution", "ph 9 buffer solution", "ph 10 buffer solution",
        "buffer ph 4 solution", "buffer ph 5 solution", "buffer ph 7 solution",
        "buffer ph 8 solution", "buffer ph 9 solution", "buffer ph 10 solution",
        "conductivity standard 5 ms/cm", "conductivity standard 12.88 ms/cm",
        "conductivity standard 30 ms/cm", "conductivity standard 80 ms/cm",
        "5 ms/cm conductivity standard", "12.88 ms/cm conductivity standard",
        "30 ms/cm conductivity standard", "80 ms/cm conductivity standard",
    ]
    keywords = [k.lower() for k in keywords]  # lowercase for matching


    # Function to normalize chemical names by word components
    def get_word_components(name):
        """Extract word components from chemical name for comparison"""
        import re
        name = name.lower().strip()

        # Split into words and clean them
        words = re.findall(r'\b\w+\b', name)

        # Remove common filler words that don't affect identity
        filler_words = {'of', 'the', 'and', 'with', 'in', 'for'}
        words = [word for word in words if word not in filler_words]

        # Sort alphabetically so order doesn't matter
        return tuple(sorted(set(words)))


    # Group chemicals by word components + manufacturer
    component_groups = defaultdict(
        list)  # Will store [(original_name, manufacturer, qty, nominal_vol, date_opened), ...]

    for row in ws.iter_rows(min_row=2, values_only=True):
        name = str(row[1] or "").strip()  # Column B: Chemical Name (keep original case)
        name_lower = name.lower()  # For keyword matching
        manufacturer = str(row[7] or "").strip()  # Column H: Manufacturer
        remaining_qty = row[6]  # Column G: Remaining Quantity
        nominal_volume = row[5]  # Column F: Bottle Nominal Volume
        date_opened = row[9] if len(row) > 9 else None  # Column J: Date Opened (index 9)

        if any(keyword in name_lower for keyword in keywords):
            try:
                # If None or invalid, use 0 instead
                qty = float(remaining_qty) if remaining_qty not in (None, "") else 0.0
                nominal_vol = float(nominal_volume) if nominal_volume not in (None, "") else 0.0
            except (TypeError, ValueError):
                qty = 0.0
                nominal_vol = 0.0

            # Get word components for grouping
            components = get_word_components(name_lower)
            group_key = (components, manufacturer)
            component_groups[group_key].append((name, manufacturer, qty, nominal_vol, date_opened))

    # Now combine groups and create summary
    critical_summary = {}
    debug_info = []

    for (components, manufacturer), items in component_groups.items():
        # Calculate usable quantity (exclude bottles with <10% remaining)
        usable_qty = 0.0
        do_not_use_qty = 0.0
        opened_bottles = 0
        unopened_bottles = 0
        do_not_use_bottles = 0

        for item in items:
            name, mfg, qty, nominal_vol, date_opened = item

            # Count opened vs unopened bottles
            if date_opened is not None and str(date_opened).strip() != "":
                opened_bottles += 1
            else:
                unopened_bottles += 1

            # Check if bottle has less than 10% remaining
            if nominal_vol > 0 and qty < (nominal_vol * 0.1):
                do_not_use_qty += qty
                do_not_use_bottles += 1
            else:
                usable_qty += qty

        total_bottles = len(items)
        total_qty = sum(item[2] for item in items)  # All quantity including unusable

        # Use the first (or most complete) name as display name
        display_name = max(items, key=lambda x: len(x[0]))[0]  # Longest name

        key = (display_name, manufacturer)
        critical_summary[key] = {
            'total_qty': total_qty,
            'usable_qty': usable_qty,  # Exclude <10% bottles
            'do_not_use_qty': do_not_use_qty,
            'opened_bottles': opened_bottles,
            'unopened_bottles': unopened_bottles,
            'total_bottles': total_bottles,
            'do_not_use_bottles': do_not_use_bottles
        }

        # Debug info
        if len(items) > 1:
            item_details = [f"'{item[0]}': {item[2]}L" for item in items]
            debug_info.append(
                f"COMBINED ({manufacturer}): {', '.join(item_details)} â†’ Total: {total_qty}L, Usable: {usable_qty}L, Do Not Use: {do_not_use_qty}L, Opened: {opened_bottles}/{total_bottles}")
        else:
            debug_info.append(
                f"SINGLE ({manufacturer}): '{items[0][0]}': Total: {total_qty}L, Usable: {usable_qty}L, Do Not Use: {do_not_use_qty}L, Opened: {opened_bottles}/{total_bottles}")

    # Print debug info to console
    print("=== WORD COMPONENT GROUPING DEBUG INFO ===")
    for info in debug_info:
        print(info)
    print(f"Total unique combinations: {len(critical_summary)}")
    print("=" * 45)


    # Create table format for critical chemicals
    def create_critical_chemicals_table(critical_data):
        if not critical_data:
            return "No critical fluids found."

        # Create table header
        table = "| **Chemical Name** | **Manufacturer** | **Usable (L)** | **Status** | **Bottle Info** |\n"
        table += "|-------------------|------------------|----------------|------------|----------------|\n"

        # Sort by usable quantity (lowest first for priority)
        sorted_items = sorted(critical_data.items(), key=lambda x: x[1]['usable_qty'])

        for (name, manufacturer), data in sorted_items:
            usable_amount = data['usable_qty']  # Use usable quantity for status decisions
            total_amount = data['total_qty']
            do_not_use_qty = data['do_not_use_qty']
            opened_bottles = data['opened_bottles']
            unopened_bottles = data['unopened_bottles']
            total_bottles = data['total_bottles']
            do_not_use_bottles = data['do_not_use_bottles']

            # Truncate long names for better table formatting
            display_name = name.title()
            if len(display_name) > 25:
                display_name = display_name[:22] + "..."

            if len(manufacturer) > 15:
                manufacturer_display = manufacturer[:12] + "..."
            else:
                manufacturer_display = manufacturer

            # Determine status based on USABLE quantity with 5L threshold
            if usable_amount < 4:
                status = "ðŸš¨ REORDER NOW"
            elif usable_amount < 5:
                status = "âš ï¸ Low Stock"
            else:
                status = "âœ… Adequate"

            # Create bottle info with "Do Not Use" indication
            bottle_info_parts = []
            if do_not_use_bottles > 0:
                bottle_info_parts.append(f"ðŸš« {do_not_use_bottles} unusable")

            if opened_bottles > do_not_use_bottles:  # Opened bottles that are still usable
                usable_opened = opened_bottles - do_not_use_bottles
                bottle_info_parts.append(f"ðŸ”“ {usable_opened} opened")

            if unopened_bottles > 0:
                bottle_info_parts.append(f"ðŸ”’ {unopened_bottles} unopened")

            bottle_info = " | ".join(bottle_info_parts) if bottle_info_parts else f"{total_bottles} bottles"

            # Show usable quantity in main column, but add note about total if different
            qty_display = f"{usable_amount:.2f}"
            if do_not_use_qty > 0:
                qty_display += f" (+{do_not_use_qty:.2f} unusable)"

            table += f"| {display_name} | {manufacturer_display} | {qty_display} | {status} | {bottle_info} |\n"

        return table


    # Create both formats
    critical_table = create_critical_chemicals_table(critical_summary)

    # Also keep the original list format for comparison/backup (using usable quantities)
    critical_list_lines = []
    for (name, manufacturer), data in critical_summary.items():
        usable_amount = data['usable_qty']
        total_amount = data['total_qty']
        do_not_use_qty = data['do_not_use_qty']
        display_name = name.title()  # Capitalize for output

        if do_not_use_qty > 0:
            main_line = f"- {display_name} ({manufacturer}) âžœ {usable_amount:.2f} L usable ({total_amount:.2f} L total, {do_not_use_qty:.2f} L unusable)"
        else:
            main_line = f"- {display_name} ({manufacturer}) âžœ {usable_amount:.2f} L"

        critical_list_lines.append(main_line)
        if usable_amount < 5:  # Updated threshold to 5L for usable quantity
            warning_line = "  - Warning: Below 5L usable threshold. Please reorder immediately."
            critical_list_lines.append(warning_line)

    critical_list_str = "\n".join(critical_list_lines)

    # Count items by status for summary (using usable quantities)
    reorder_count = sum(1 for data in critical_summary.values() if data['usable_qty'] < 4)
    low_stock_count = sum(1 for data in critical_summary.values() if 4 <= data['usable_qty'] < 5)
    adequate_count = sum(1 for data in critical_summary.values() if data['usable_qty'] >= 5)

    # Send critical fluids to Teams with enhanced table format
    msg_critical = pymsteams.connectorcard(
        "https://nervtechnology2.webhook.office.com/webhookb2/9b48b976-ff78-47d9-84af-0c86adb460bd@c943a20e-cde2-4f23-b31e-66242a699eb2/IncomingWebhook/2efe91b202c844cd9e3ad8f664443bb3/756d53aa-a382-47d3-9d8c-2d22fa02b8a3/V24Osd4C7KfMwor8lyRXSbBRdZcuzt6wgDMRlLNuh9QtE1")

    summary_text = f"**Summary:** {reorder_count} need immediate reorder, {low_stock_count} low stock, {adequate_count} adequate (based on usable quantities)"

    msg_critical.text(
        "**Weekly Critical Chemical Update Alert**\n\n"
        f"{summary_text}\n\n"
        f"{critical_table}\n\n"
        "---\n"
        "**Legend:** ðŸš¨ = Reorder immediately (<4L usable) | âš ï¸ = Low stock (4-5L usable) | âœ… = Adequate (>5L usable)\n"
        "ðŸš« = Bottles with <10% volume (Do Not Use) | ðŸ”“ = Opened bottles | ðŸ”’ = Unopened bottles"
    )
    msg_critical.send()

    # === PART 2: Enhanced Reorder Updates Table ===
    ws_reorder = wb['ReorderUpdates']

    # Dictionary to group by chemical name and manufacturer
    reorder_groups = defaultdict(list)

    # Collect all items from ReorderUpdates sheet
    for row in ws_reorder.iter_rows(min_row=2, values_only=True):
        if not row or len(row) < 7:  # Make sure we have enough columns
            continue

        name = str(row[0] or "").strip()  # Column A: Chemical Name
        manufacturer = str(row[6] or "").strip()  # Column G: Manufacturer
        remaining_qty = row[2]  # Column C: Remaining Quantity
        expiry_alert = str(row[4] or "").strip()  # Column E: Expiry Alert
        quantity_alert = str(row[5] or "").strip()  # Column F: Quantity/Empty Status

        if not name:  # Skip if no chemical name
            continue

        # Convert quantity to float, default to 0 if invalid
        try:
            qty = float(remaining_qty) if remaining_qty not in (None, "") else 0.0
        except (TypeError, ValueError):
            qty = 0.0

        # Determine status - ALWAYS include expired items regardless of quantity
        status = None
        if expiry_alert == "Expired":
            status = "Expired"
        elif quantity_alert == "Empty":
            status = "Empty"
        elif quantity_alert == "Do Not Use":
            status = "Do Not Use"
        elif expiry_alert == "Order More" or quantity_alert == "Order More":
            status = "Order More"

        if status:  # Only add if there's a relevant status
            group_key = (name, manufacturer)
            reorder_groups[group_key].append((qty, status))

    # Process groups to combine quantities and determine final status
    reorder_data = []

    for (name, manufacturer), items in reorder_groups.items():
        # Calculate different quantity totals
        total_qty = sum(item[0] for item in items)
        usable_qty = sum(item[0] for item in items if item[1] not in ["Do Not Use"])
        do_not_use_qty = sum(item[0] for item in items if item[1] == "Do Not Use")

        # Determine priority status (Expired > Empty > Do Not Use > Order More)
        statuses = [item[1] for item in items]
        if "Expired" in statuses:
            final_status = "ðŸ”´ Expired"
        elif "Empty" in statuses:
            final_status = "âš« Empty"
        elif "Do Not Use" in statuses and len(set(statuses)) == 1:  # Only "Do Not Use" items
            final_status = "ðŸš« Do Not Use"
        else:
            final_status = "ðŸŸ¡ Order More"

        # Prepare quantity display
        if do_not_use_qty > 0 and usable_qty > 0:
            qty_display = f"{usable_qty:.2f} usable (+{do_not_use_qty:.2f} unusable)"
        elif do_not_use_qty > 0:
            qty_display = f"{do_not_use_qty:.2f} (all unusable)"
        else:
            qty_display = f"{total_qty:.2f}"

        reorder_data.append((name, manufacturer, qty_display, final_status))


    # Create enhanced table format
    def create_reorder_table(reorder_data):
        if not reorder_data:
            return "No items requiring attention at this time."

        # Create table header
        table = "| **Chemical Name** | **Manufacturer** | **Remaining (L)** | **Status** |\n"
        table += "|-------------------|------------------|-------------------|------------|\n"

        # Sort by status priority (Expired first, then Empty, then Do Not Use, then Order More)
        status_priority = {"ðŸ”´ Expired": 1, "âš« Empty": 2, "ðŸš« Do Not Use": 3, "ðŸŸ¡ Order More": 4}
        sorted_data = sorted(reorder_data, key=lambda x: (status_priority.get(x[3], 5), x[0]))

        for name, manufacturer, qty_display, status in sorted_data:
            # Truncate long names for better table formatting
            display_name = name.title() if name else "Unknown"
            if len(display_name) > 30:
                display_name = display_name[:27] + "..."

            display_manufacturer = manufacturer if manufacturer else "Unknown"
            if len(display_manufacturer) > 15:
                display_manufacturer = display_manufacturer[:12] + "..."

            table += f"| {display_name} | {display_manufacturer} | {qty_display} | {status} |\n"

        return table


    # Create the table and summary
    reorder_table = create_reorder_table(reorder_data)

    # Count by status
    expired_count = sum(1 for item in reorder_data if "Expired" in item[3])
    empty_count = sum(1 for item in reorder_data if "Empty" in item[3])
    do_not_use_count = sum(1 for item in reorder_data if "Do Not Use" in item[3])
    order_more_count = sum(1 for item in reorder_data if "Order More" in item[3])

    summary = f"**Summary:** {expired_count} expired, {empty_count} empty, {do_not_use_count} do not use, {order_more_count} need reordering"

    # Send the enhanced table message
    msg_table = pymsteams.connectorcard(
        "https://nervtechnology2.webhook.office.com/webhookb2/9b48b976-ff78-47d9-84af-0c86adb460bd@c943a20e-cde2-4f23-b31e-66242a699eb2/IncomingWebhook/2efe91b202c844cd9e3ad8f664443bb3/756d53aa-a382-47d3-9d8c-2d22fa02b8a3/756d53aa-a382-47d3-9d8c-2d22fa02b8a3/V24Osd4C7KfMwor8lyRXSbBRdZcuzt6wgDMRlLNuh9QtE1")
    msg_table.text(
        "**Weekly Inventory Status Report**\n\n"
        f"{summary}\n\n"
        f"{reorder_table}\n\n"
        "---\n"
        "**Legend:** ðŸ”´ = Expired | âš« = Empty | ðŸš« = Do Not Use (<10% remaining) | ðŸŸ¡ = Needs reordering"
    )
    msg_table.send()

    print(
        f"Weekly alerts sent successfully. Found {len(critical_summary)} critical fluids, {expired_count} expired items, {empty_count} empty items, {do_not_use_count} do not use items, and {order_more_count} items needing reorder.")

except Exception as e:
    print(f"Error sending weekly alerts: {e}")


# ENHANCED REORDER ALERT FUNCTION
def main_reorder_alert():
    """Enhanced reorder alert with proper order tracking and table format"""
    try:
        # Load workbook and sheet
        wb = load_workbook('/Users/ishanasahota/Desktop/fluidAI/rnd_chemical_inventory.xlsx', data_only=True)
        ws = wb['InventoryData']

        order_more_items = []
        do_not_use_items = []
        expired_items = []

        for row in ws.iter_rows(min_row=2, values_only=True):
            if not row or len(row) < 6:  # Skip empty rows
                continue

            item_name = row[0]  # Column A: Chemical Name
            quantity_alert_e = row[4]  # Column E: Expiry alert column
            quantity_alert_f = row[5]  # Column F: Quantity alert column

            # Check status - ALWAYS include expired items
            if quantity_alert_e == "Expired":
                expired_items.append(item_name)
            elif quantity_alert_f == "Do Not Use":
                do_not_use_items.append(item_name)
            elif quantity_alert_e == "Order More" or quantity_alert_f == "Order More":
                order_more_items.append(item_name)

        # Combine all items that need attention
        all_items = []

        # Add expired items first (highest priority)
        for item in expired_items:
            all_items.append((item, "ðŸ”´ Expired"))

        # Add do not use items
        for item in do_not_use_items:
            all_items.append((item, "ðŸš« Do Not Use"))

        # Add order more items
        for item in order_more_items:
            all_items.append((item, "ðŸŸ¡ Order More"))

        # Create table format for reorder items
        if all_items:
            table_msg = "| **Chemical Name** | **Status** |\n"
            table_msg += "|-------------------|------------|\n"
            for item_name, status in all_items:
                # Truncate long names
                display_name = (item_name[:35] + "...") if len(item_name) > 38 else item_name
                table_msg += f"| {display_name} | {status} |\n"
        else:
            table_msg = "No items need immediate attention at this time."

        # Send Teams message with table format
        msg_reorder = pymsteams.connectorcard(
            "https://nervtechnology2.webhook.office.com/webhookb2/9b48b976-ff78-47d9-84af-0c86adb460bd@c943a20e-cde2-4f23-b31e-66242a699eb2/IncomingWebhook/2efe91b202c844cd9e3ad8f664443bb3/756d53aa-a382-47d3-9d8c-2d22fa02b8a3/V24Osd4C7KfMwor8lyRXSbBRdZcuzt6wgDMRlLNuh9QtE1")

        total_count = len(expired_items) + len(do_not_use_items) + len(order_more_items)
        summary_breakdown = f"Expired: {len(expired_items)}, Do Not Use: {len(do_not_use_items)}, Order More: {len(order_more_items)}"

        msg_reorder.text(
            "**Critical Chemical Reorder Alert**\n\n"
            f"**Items requiring immediate attention: {total_count}**\n"
            f"**Breakdown:** {summary_breakdown}\n\n"
            f"{table_msg}\n\n"
            "---\n"
            "**Legend:** ðŸ”´ = Expired (handle regardless of quantity) | ðŸš« = Do Not Use (<10% remaining) | ðŸŸ¡ = Needs reordering"
        )
        msg_reorder.send()
    except Exception as e:
        print(f"Error sending weekly alerts: {e}")


# Add this debug version at the top of your script to test Teams connectivity

def test_teams_connection():
    """Test basic Teams webhook connectivity"""
    try:
        import pymsteams
        test_msg = pymsteams.connectorcard(
            "https://nervtechnology2.webhook.office.com/webhookb2/9b48b976-ff78-47d9-84af-0c86adb460bd@c943a20e-cde2-4f23-b31e-66242a699eb2/IncomingWebhook/2efe91b202c844cd9e3ad8f664443bb3/756d53aa-a382-47d3-9d8c-2d22fa02b8a3/V24Osd4C7KfMwor8lyRXSbRdZcuzt6wgDMRlLNuh9QtE1")
        test_msg.text("Test message - script is working")
        response = test_msg.send()
        print(f"Teams test message result: {response}")
        return True
    except Exception as e:
        print(f"Teams connection test failed: {e}")
        import traceback
        traceback.print_exc()
        return False


# Enhanced message sending with better error handling
def send_teams_message_safe(webhook_url, message_content, message_type="Alert"):
    """Send Teams message with comprehensive error handling"""
    try:
        import pymsteams

        # Check message length
        if len(message_content) > 28000:  # Teams has ~28KB limit
            print(f"Warning: {message_type} message is {len(message_content)} characters, truncating...")
            message_content = message_content[:27000] + "\n\n...[Message truncated due to size limit]"

        msg = pymsteams.connectorcard(webhook_url)
        msg.text(message_content)

        # Send and capture response
        response = msg.send()
        print(f"{message_type} message sent successfully. Response: {response}")
        return True

    except Exception as e:
        print(f"Error sending {message_type} message: {str(e)}")
        print(f"Message length was: {len(message_content)} characters")
        import traceback
        traceback.print_exc()
        return False


# Test the connection first
print("Testing Teams webhook connection...")
if test_teams_connection():
    print("âœ“ Teams connection test passed")
else:
    print("âœ— Teams connection test failed - check webhook URL")

# Then replace your existing message sending code with:

# For critical fluids message:
webhook_url = "https://nervtechnology2.webhook.office.com/webhookb2/9b48b976-ff78-47d9-84af-0c86adb460bd@c943a20e-cde2-4f23-b31e-66242a699eb2/IncomingWebhook/2efe91b202c844cd9e3ad8f664443bb3/756d53aa-a382-47d3-9d8c-2d22fa02b8a3/V24Osd4C7KfMwor8lyRXSbRdZcuzt6wgDMRlLNuh9QtE1"

critical_message = (
    "**Weekly Critical Chemical Update Alert**\n\n"
    f"{summary_text}\n\n"
    f"{critical_table}\n\n"
    "---\n"
    "**Legend:** ðŸš¨ = Reorder immediately (<4L usable) | âš ï¸ = Low stock (4-5L usable) | âœ… = Adequate (>5L usable)\n"
    "ðŸš« = Bottles with <10% volume (Do Not Use) | ðŸ”“ = Opened bottles | ðŸ”’ = Unopened bottles"
)

send_teams_message_safe(webhook_url, critical_message, "Critical Fluids")

# For reorder updates message:
reorder_message = (
    "**Weekly Inventory Status Report**\n\n"
    f"{summary}\n\n"
    f"{reorder_table}\n\n"
    "---\n"
    "**Legend:** ðŸ”´ = Expired | âš« = Empty | ðŸš« = Do Not Use (<10% remaining) | ðŸŸ¡ = Needs reordering"
)

send_teams_message_safe(webhook_url, reorder_message, "Reorder Updates")
