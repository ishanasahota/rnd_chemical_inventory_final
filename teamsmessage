from openpyxl import load_workbook
import pymsteams
from collections import defaultdict
import tkinter as tk
from tkinter import messagebox

try:
    # Load workbook and InventoryData
    wb = load_workbook('/Users/ishanasahota/Desktop/fluidAI/rnd_inventory_data_2.xlsx', data_only=True)
    ws = wb['InventoryData']

    # PART 1: Weekly Summary of Critical Fluids with Table Format
    keywords = [
        "buffer solution ph 4", "buffer solution ph 5", "buffer solution ph 7",
        "buffer solution ph 8", "buffer solution ph 9", "buffer solution ph 10",
        "ph 4 buffer solution", "ph 5 buffer solution", "ph 7 buffer solution",
        "ph 8 buffer solution", "ph 9 buffer solution", "ph 10 buffer solution",
        "buffer ph 4 solution", "buffer ph 5 solution", "buffer ph 7 solution",
        "buffer ph 8 solution", "buffer ph 9 solution", "buffer ph 10 solution",
        "conductivity standard 5 ms/cm", "conductivity standard 12.88 ms/cm",
        "conductivity standard 30 ms/cm", "conductivity standard 80 ms/cm",
        "5 ms/cm conductivity standard", "12.88 ms/cm conductivity standard",
        "30 ms/cm conductivity standard", "80 ms/cm conductivity standard",
    ]
    keywords = [k.lower() for k in keywords]  # lowercase for matching


    # Function to normalize chemical names by word components
    def get_word_components(name):
        """Extract word components from chemical name for comparison"""
        import re
        name = name.lower().strip()

        # Split into words and clean them
        words = re.findall(r'\b\w+\b', name)

        # Remove common filler words that don't affect identity
        filler_words = {'of', 'the', 'and', 'with', 'in', 'for'}
        words = [word for word in words if word not in filler_words]

        # Sort alphabetically so order doesn't matter
        return tuple(sorted(set(words)))


    # Group chemicals by word components + manufacturer
    component_groups = defaultdict(list)  # Will store [(original_name, manufacturer, qty), ...]

    for row in ws.iter_rows(min_row=2, values_only=True):
        name = str(row[1] or "").strip()  # Column B: Chemical Name (keep original case)
        name_lower = name.lower()  # For keyword matching
        manufacturer = str(row[7] or "").strip()  # Column H: Manufacturer
        remaining_qty = row[6]  # Column G: Remaining Quantity

        if any(keyword in name_lower for keyword in keywords):
            try:
                # If None or invalid, use 0 instead
                qty = float(remaining_qty) if remaining_qty not in (None, "") else 0.0
            except (TypeError, ValueError):
                qty = 0.0

            # Get word components for grouping
            components = get_word_components(name_lower)
            group_key = (components, manufacturer)
            component_groups[group_key].append((name, manufacturer, qty))

    # Now combine groups and create summary
    critical_summary = {}
    debug_info = []

    for (components, manufacturer), items in component_groups.items():
        total_qty = sum(item[2] for item in items)  # Sum all quantities

        # Use the first (or most complete) name as display name
        display_name = max(items, key=lambda x: len(x[0]))[0]  # Longest name

        key = (display_name, manufacturer)
        critical_summary[key] = total_qty

        # Debug info
        if len(items) > 1:
            item_details = [f"'{item[0]}': {item[2]}L" for item in items]
            debug_info.append(f"COMBINED ({manufacturer}): {', '.join(item_details)} â†’ Total: {total_qty}L")
        else:
            debug_info.append(f"SINGLE ({manufacturer}): '{items[0][0]}': {total_qty}L")

    # Print debug info to console
    print("=== WORD COMPONENT GROUPING DEBUG INFO ===")
    for info in debug_info:
        print(info)
    print(f"Total unique combinations: {len(critical_summary)}")
    print("=" * 45)


    # Create table format for critical chemicals
    def create_critical_chemicals_table(critical_data):
        if not critical_data:
            return "No critical fluids found."

        # Create table header
        table = "| **Chemical Name** | **Manufacturer** | **Remaining (L)** | **Status** |\n"
        table += "|-------------------|------------------|-------------------|------------|\n"

        # Sort by remaining quantity (lowest first for priority)
        sorted_items = sorted(critical_data.items(), key=lambda x: x[1])

        for (name, manufacturer), total_amount in sorted_items:
            # Truncate long names for better table formatting
            display_name = name.title()
            if len(display_name) > 25:
                display_name = display_name[:40] + "..."

            if len(manufacturer) > 15:
                manufacturer_display = manufacturer[:12] + "..."
            else:
                manufacturer_display = manufacturer

            # Determine status
            if total_amount < 6:
                status = "ðŸš¨ REORDER NOW"
            elif total_amount < 10:
                status = "âš ï¸ Low Stock"
            else:
                status = "âœ… Adequate"

            table += f"| {display_name} | {manufacturer_display} | {total_amount:.2f} | {status} |\n"

        return table


    # Create both formats
    critical_table = create_critical_chemicals_table(critical_summary)

    # Also keep the original list format for comparison/backup
    critical_list_lines = []
    for (name, manufacturer), total_amount in critical_summary.items():
        display_name = name.title()  # Capitalize for output
        main_line = f"- {display_name} ({manufacturer}) âžœ {total_amount:.2f} L"
        critical_list_lines.append(main_line)
        if total_amount < 6:
            warning_line = "  - Warning: Almost at 1 bottle. Please reorder immediately."
            critical_list_lines.append(warning_line)

    critical_list_str = "\n".join(critical_list_lines)

    # Count items by status for summary
    reorder_count = sum(1 for qty in critical_summary.values() if qty < 6)
    low_stock_count = sum(1 for qty in critical_summary.values() if 6 <= qty < 10)
    adequate_count = sum(1 for qty in critical_summary.values() if qty >= 10)

    # Send critical fluids to Teams with enhanced table format
    msg_critical = pymsteams.connectorcard(
        "https://nervtechnology2.webhook.office.com/webhookb2/9b48b976-ff78-47d9-84af-0c86adb460bd@c943a20e-cde2-4f23-b31e-66242a699eb2/IncomingWebhook/2efe91b202c844cd9e3ad8f664443bb3/756d53aa-a382-47d3-9d8c-2d22fa02b8a3/V24Osd4C7KfMwor8lyRXSbBRdZcuzt6wgDMRlLNuh9QtE1")

    summary_text = f"**Summary:** {reorder_count} need immediate reorder, {low_stock_count} low stock, {adequate_count} adequate"

    msg_critical.text(
        "**Weekly Critical Chemical Update Alert**\n\n"
        f"{summary_text}\n\n"
        f"{critical_table}\n\n"
        "---\n"
        "**Legend:** ðŸš¨ = Reorder immediately (<6L) | âš ï¸ = Low stock (6-10L) | âœ… = Adequate (>10L)"
    )
    msg_critical.send()

    # === PART 2: Enhanced Reorder Updates Table ===
    ws_reorder = wb['ReorderUpdates']

    # Dictionary to group by chemical name and manufacturer
    reorder_groups = defaultdict(list)

    # Collect all items from ReorderUpdates sheet
    for row in ws_reorder.iter_rows(min_row=2, values_only=True):
        if not row or len(row) < 7:  # Make sure we have enough columns
            continue

        name = str(row[0] or "").strip()  # Column A: Chemical Name
        manufacturer = str(row[6] or "").strip()  # Column G: Manufacturer
        remaining_qty = row[2]  # Column C: Remaining Quantity
        expiry_alert = str(row[4] or "").strip()  # Column E: Expiry Alert
        quantity_alert = str(row[5] or "").strip()  # Column F: Quantity/Empty Status

        if not name:  # Skip if no chemical name
            continue

        # Convert quantity to float, default to 0 if invalid
        try:
            qty = float(remaining_qty) if remaining_qty not in (None, "") else 0.0
        except (TypeError, ValueError):
            qty = 0.0

        # Determine status
        status = None
        if expiry_alert == "Expired":
            status = "Expired"
        elif quantity_alert == "Empty":
            status = "Empty"
        elif expiry_alert == "Order More" or quantity_alert == "Order More":
            status = "Order More"

        if status:  # Only add if there's a relevant status
            group_key = (name, manufacturer)
            reorder_groups[group_key].append((qty, status))

    # Process groups to combine quantities and determine final status
    reorder_data = []

    for (name, manufacturer), items in reorder_groups.items():
        # Combine quantities for same name+manufacturer
        total_qty = sum(item[0] for item in items)

        # Determine priority status (Expired > Empty > Order More)
        statuses = [item[1] for item in items]
        if "Expired" in statuses:
            final_status = "ðŸ”´ Expired"
        elif "Empty" in statuses:
            final_status = "âš« Empty"
        else:
            final_status = "ðŸŸ¡ Order More"

        reorder_data.append((name, manufacturer, total_qty, final_status))


    # Create enhanced table format
    def create_reorder_table(reorder_data):
        if not reorder_data:
            return "No items requiring attention at this time."

        # Create table header
        table = "| **Chemical Name** | **Manufacturer** | **Remaining (L)** | **Status** |\n"
        table += "|-------------------|------------------|-------------------|------------|\n"

        # Sort by status priority (Expired first, then Empty, then Order More)
        status_priority = {"ðŸ”´ Expired": 1, "âš« Empty": 2, "ðŸŸ¡ Order More": 3}
        sorted_data = sorted(reorder_data, key=lambda x: (status_priority.get(x[3], 4), x[2]))

        for name, manufacturer, qty, status in sorted_data:
            # Truncate long names for better table formatting
            display_name = name.title() if name else "Unknown"
            if len(display_name) > 30:
                display_name = display_name[:27] + "..."

            display_manufacturer = manufacturer if manufacturer else "Unknown"
            if len(display_manufacturer) > 15:
                display_manufacturer = display_manufacturer[:12] + "..."

            table += f"| {display_name} | {display_manufacturer} | {qty:.2f} | {status} |\n"

        return table


    # Create the table and summary
    reorder_table = create_reorder_table(reorder_data)

    # Count by status
    expired_count = sum(1 for item in reorder_data if "Expired" in item[3])
    empty_count = sum(1 for item in reorder_data if "Empty" in item[3])
    order_more_count = sum(1 for item in reorder_data if "Order More" in item[3])

    summary = f"**Summary:** {expired_count} expired, {empty_count} empty, {order_more_count} need reordering"

    # Send the enhanced table message
    msg_table = pymsteams.connectorcard(
        "https://nervtechnology2.webhook.office.com/webhookb2/9b48b976-ff78-47d9-84af-0c86adb460bd@c943a20e-cde2-4f23-b31e-66242a699eb2/IncomingWebhook/2efe91b202c844cd9e3ad8f664443bb3/756d53aa-a382-47d3-9d8c-2d22fa02b8a3/V24Osd4C7KfMwor8lyRXSbBRdZcuzt6wgDMRlLNuh9QtE1")
    msg_table.text(
        "**Weekly Inventory Status Report**\n\n"
        f"{summary}\n\n"
        f"{reorder_table}\n\n"
        "---\n"
        "**Legend:** ðŸ”´ = Expired | âš« = Empty | ðŸŸ¡ = Needs reordering"
    )
    msg_table.send()

    print(
        f"Weekly alerts sent successfully. Found {len(critical_summary)} critical fluids, {expired_count} expired items, {empty_count} empty items, and {order_more_count} items needing reorder.")

except Exception as e:
    print(f"Error sending weekly alerts: {e}")


# ENHANCED REORDER ALERT FUNCTION
def main_reorder_alert():
    """Enhanced reorder alert with proper order tracking and table format"""
    try:
        # Load workbook and sheet
        wb = load_workbook('/Users/ishanasahota/Desktop/fluidAI/rnd_chemical_inventory.xlsx', data_only=True)
        ws = wb['InventoryData']

        order_more_items = []

        for row in ws.iter_rows(min_row=2, values_only=True):
            if not row or len(row) < 6:  # Skip empty rows
                continue

            item_name = row[0]  # Column A: Chemical Name
            quantity_alert_e = row[4]  # Column E: Expiry alert column
            quantity_alert_f = row[5]  # Column F: Quantity alert column

            # Check if "Order More" is in either column E or F
            if quantity_alert_e == "Order More" or quantity_alert_f == "Order More":
                order_more_items.append(item_name)

        # Create table format for reorder items
        if order_more_items:
            table_msg = "| **Chemical Name** | **Status** |\n"
            table_msg += "|-------------------|------------|\n"
            for item in order_more_items:
                # Truncate long names
                display_name = (item[:35] + "...") if len(item) > 38 else item
                table_msg += f"| {display_name} | Order More |\n"
        else:
            table_msg = "No items need reordering at this time."

        # Send Teams message with table format
        msg_reorder = pymsteams.connectorcard(
            "https://nervtechnology2.webhook.office.com/webhookb2/9b48b976-ff78-47d9-84af-0c86adb460bd@c943a20e-cde2-4f23-b31e-66242a699eb2/IncomingWebhook/2efe91b202c844cd9e3ad8f664443bb3/756d53aa-a382-47d3-9d8c-2d22fa02b8a3/V24Osd4C7KfMwor8lyRXSbBRdZcuzt6wgDMRlLNuh9QtE1")
        msg_reorder.text(
            "**Critical Chemical Reorder Alert**\n\n"
            f"**Items requiring immediate attention: {len(order_more_items)}**\n\n"
            f"{table_msg}"
        )
        msg_reorder.send()
    except Exception as e:
        print(f"Error sending weekly alerts: {e}")
